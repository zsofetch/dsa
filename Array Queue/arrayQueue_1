//array implementation of a queue
//variation 1: queue is a static array with count front and rear

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

#define MAX 10

typedef struct {
    int items[MAX];
    int count;
} List;

typedef struct {
    List list;
    int front;
    int rear;
} Queue;

//function prototypes 
Queue* initialize();
bool isFull(Queue* q);
bool isEmpty(Queue* q);
void enqueue(Queue* q, int value);
int dequeue(Queue* q);
int peekFront(Queue* q);
void display(Queue* q);

//helper function
void cleanup(Queue* q);

Queue* initialize() {
    //allocate memory
    Queue* q = (Queue*)malloc(sizeof(Queue));
    
    if (q != NULL) {
        q->list.count = 0; //initialize list count to 0
        q->front = -1; //initialize front and rear pointer to -1 indicating empty queue
        q->rear = -1;
    }
    return q;
}

bool isFull(Queue* q) {
    return (q->list.count == MAX);
    // Check if the number of elements equals maximum capacity
}
bool isEmpty(Queue* q) {
    return (q->list.count == 0);
    // Check if the number of elements is zero
}
void enqueue(Queue* q, int value) {
    if (!isFull(q)) { //is queue is not full
        //if the queue is empty, set both front and rear to 0
        if (isEmpty(q)) {
            q->front = 0;
            q->rear = 0;
        } else {
            q->rear = (q->rear + 1) % MAX;
            //otherwise, update the rear pointer circularly 
        }
        q->list.items[q->rear] = value;
        /*           ^^^^^^^^^   ^^^^^
           Access items array    value to store
           at rear position
           Add the new value to the list at the rear position as per checklist*/  
        q->list.count++;
        // Increment the count
        } else {
        printf("Queue is full! Cannot enqueue %d\n", value);
    }
}

int dequeue(Queue* q) {
    int removedValue = -1; // Default return value for empty queue
    // Variable to store  Default value if queue is empty
    // the removed value
    
    if (!isEmpty(q)) {
       
        removedValue = q->list.items[q->front];
        //             ^^^^^^^^^^^^^^^^^^^^^^^
        // Store the value found at the front of the queue before it is removed
        // Access the element at front position
        
        // STEP 3: If this is the last element in the queue, reset the queue to its initial empty state
        if (q->list.count == 1) {
            // ^^^^^^^^^^^^^^^^^^
            // Check if this is the last element (count == 1)
            
            q->front = -1;
            //         ^^^^
            // Reset front to -1 (empty state)
            
            q->rear = -1;
            //        ^^^^
            // Reset rear to -1 (empty state)
            // If this is the last element, reset the queue to initial empty state
        } else {
            // STEP 4: If not, update the front pointer circularly
            q->front = (q->front + 1) % MAX;
            //         ^^^^^^^^^^^^^^^^^^^^
            // If not, update the front pointer circularly 
            // (front = (front + 1) % MAX) as per checklist
            // Move front to next element using modular arithmetic
        }
        
        // STEP 5: Decrement the count
        q->list.count--;
        // Decrement the count as per checklist
    }  else {
        printf("Queue is empty! Cannot dequeue.\n");
    }
    
    return removedValue;
    // Return the removed value
}

int peekFront(Queue* q) {
    if (!isEmpty(q)) {
        // Check if the queue is empty (if not empty, proceed)
        return q->list.items[q->front];
        //     ^^^^^^^^^^^^^^^^^^^^^^^
        // Return the value at the front of the queue as per checklist
        // Access element at front position without removing it
    }
    return -1;
    // Return default value if queue is empty
}

void display(Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty\n");
        return;
    }
    
    printf("Queue: [");
    
    // STEP 2: Loop through the queue from front to rear and print each element
    int i = q->front;  // Start from front
    // Iterator  Starting position (front of queue)
    
    int count = 0; 
   
    // Loop through queue elements
    while (count < q->list.count) {
        // Continue while we haven't printed all elements
        // Loop through the queue from front to rear as per checklist
        
        printf("%d", q->list.items[i]);
        count++;

        //comma separator
        if (count < q->list.count)
            // Check if not the last element
            printf(", ");
            // Print separator
        
        // Move to next position circularly
        i = (i + 1) % MAX;
        // Move to next position using modular arithmetic
        // Ensures circular traversal of the queue
    }
    
    printf("]\n");
    printf("Count: %d, Front: %d, Rear: %d\n", 
           q->list.count, q->front, q->rear);
}

void cleanup(Queue* q) {
    if (q != NULL) {
        // Check if pointer is not NULL (safety check)
        
        free(q);
        // Free the memory allocated for the queue structure
    }
}

int main() {
    // Create and initialize queue
    Queue* myQueue = initialize();
    
    printf("=== Queue Demonstration ===\n\n");
    
    // Test enqueue operations
    printf("Enqueuing values: 10, 20, 30, 40, 50\n");
    enqueue(myQueue, 10);
    enqueue(myQueue, 20);
    enqueue(myQueue, 30);
    enqueue(myQueue, 40);
    enqueue(myQueue, 50);
    display(myQueue);
    
    // Test front function
    printf("\nFront element: %d\n", peekFront(myQueue));
    
    // Test dequeue operations
    printf("\nDequeuing 2 elements:\n");
    printf("Dequeued: %d\n", dequeue(myQueue));
    printf("Dequeued: %d\n", dequeue(myQueue));
    display(myQueue);
    
    // Test circular behavior
    printf("\nEnqueuing more values to test circular behavior: 60, 70\n");
    enqueue(myQueue, 60);
    enqueue(myQueue, 70);
    display(myQueue);
    
    // Clean up
    cleanup(myQueue);
    printf("\nQueue cleaned up successfully.\n");
}